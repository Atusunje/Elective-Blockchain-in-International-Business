[
  {
    "objectID": "orderofoperations.html",
    "href": "orderofoperations.html",
    "title": "Order of operations ü§î",
    "section": "",
    "text": "See book section\n\n\nMathematical Order of Operations\nMathematical order of operations refers to the rules that dictate the sequence in which mathematical operations should be performed in an expression. These rules ensure that every mathematical expression is evaluated in a consistent and unambiguous manner. The order of operations is also known as ‚ÄúPEMDAS‚Äù which is an acronym representing the sequence of operations: Parentheses, Exponents, Multiplication and Division (from left to right), and Addition and Subtraction (from left to right).\nPython, along with many other programming languages, follows the standard order of operations used in mathematics. The order of operations is essential to obtain accurate and meaningful results. Let‚Äôs break down each component of the order of operations and illustrate them with Python examples, including real-world scenarios.\n1. Parentheses\nParentheses are used to indicate which parts of an expression should be evaluated first. Expressions within parentheses are calculated before anything else.\nExample 1: Simple Parentheses\n\n\nCode\nresult = (4 + 3) * 2\nprint(result)  # Output: 14 (since 4 + 3 = 7, and 7 * 2 = 14)\n\n\n14\n\n\n2. Exponents\nExponents are mathematical operations that raise a base to a certain power.\nExample 2: Exponents\n\n\nCode\nresult = 2 ** 3 + 4\nprint(result)  # Output: 12 (since 2 ** 3 = 8, and 8 + 4 = 12)\n\n\n12\n\n\n3. Multiplication and Division\nThese operations are performed from left to right, whichever comes first in the expression.\nExample 3: Multiplication and Division\n\n\nCode\nresult = 10 / 2 * 3\nprint(result)  # Output: 15 (since 10 / 2 = 5, and 5 * 3 = 15)\n\n\n15.0\n\n\n4. Addition and Subtraction\nSimilarly, addition and subtraction are performed from left to right, whichever comes first in the expression.\nExample 4: Addition and Subtraction\n\n\nCode\nresult = 8 - 3 + 2\nprint(result)  # Output: 7 (since 8 - 3 = 5, and 5 + 2 = 7)\n\n\n7\n\n\nReal-World Examples\nLet‚Äôs consider some real-world examples where understanding the order of operations is crucial:\nExample 5: Shopping Calculations\n\n\nCode\nprice_per_item = 5\ntax_rate = 0.08\nquantity = 3\n\ntotal_cost = price_per_item * quantity + (price_per_item * quantity) * tax_rate\nprint(total_cost)  # Output: 16.2 (5 * 3 = 15, 15 + 15 * 0.08 = 16.2)\n\n\n16.2\n\n\nExample 6: Engineering Calculation\n\n\nCode\nimport math\n\nbase_length = 6.5 # a\nheight = 8.2 # b\n\nhypotenuse = math.sqrt(base_length ** 2 + height ** 2)\nprint(hypotenuse)  # Output: 10.463...\n\n\n10.463746938836012\n\n\n\nIn the second example, we use the Pythagorean theorem to find the length of the hypotenuse in a right-angled triangle. The order of operations ensures that the squares and addition are performed before the square root operation.\n\nAssignment: Make a short video explaining how to calculate distances between two coordinates. Do proper research and use code demos.\nStretch: Expand your video with an exploration of how to calculate the distance between geographical locations using their coordinates taking into account the curvature of the earth. Discuss and illustrate with code examples and maps. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "See book section\n\n\nRelationship Between Mathematical Functions and Functions in Python\nMathematical functions and functions in Python share some fundamental concepts, but they are implemented and used in different ways. Understanding their relationship can help us leverage the power of Python libraries like SymPy for symbolic mathematics and visualization libraries for plotting.\n1. Mathematical Functions:\nIn mathematics, functions are a fundamental concept that relates an input (or a set of inputs) to an output. A mathematical function typically takes one or more variables as inputs and produces a single output. Functions are often denoted by symbols like \\(f(x)\\) or \\(g(x, y)\\).\nExample: Mathematical Function\n\\[f(x) = x^2 + 6x + 9\\]\n2. Functions in Python:\nIn Python, functions are blocks of code that perform a specific task. They can take input arguments and return a result. Python functions can be defined using the def keyword and can be called multiple times within a program.\nExample: Python Function\n\n\nCode\ndef f(x):\n    return x**2 + 6*x + 9\n\n\n3. Using SymPy for Symbolic Mathematics:\nSymPy is a Python library for symbolic mathematics. It allows us to work with mathematical expressions in symbolic form, just like we do in mathematics. SymPy functions can be used to manipulate and simplify algebraic expressions.\nExample 1: Plotting a Mathematical Function\n\n\nCode\nfrom sympy import *\n\nx = symbols('x')\nf = x**2 + 6*x + 9\n\nplot(f, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x109db26d0&gt;\n\n\nExample 2: Plotting Multiple Mathematical Functions\n\n\nCode\nfd = 20*x - 40\n\nplot(f, fd, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x109db2220&gt;\n\n\nExample 3: Plotting Multiple Mathematical Functions\n\n\nCode\ng = sin(x)\nh = sin(x - pi)\ngh = g+h\n\nplot(g, h, gh, (x, -2*pi, 2*pi), ylim=(-1, 1))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x12c02c310&gt;\n\n\nConclusion:\nThe relationship between mathematical functions and functions in Python revolves around the idea of relating inputs to outputs. Python provides a practical and versatile environment for working with functions, and libraries like SymPy and Matplotlib enhance the capabilities to handle symbolic mathematics and create visual representations of functions. By understanding this relationship, you can leverage Python‚Äôs functionality for mathematical computations and visualization, making it a powerful tool for various scientific and engineering tasks."
  },
  {
    "objectID": "numbertheory.html",
    "href": "numbertheory.html",
    "title": "Number Theory ü§î",
    "section": "",
    "text": "See book section\n\n\nNumber theory is a branch of mathematics that deals with the properties and relationships of numbers, especially integers. Python, like many programming languages, has several built-in types to handle numbers, each with its own capabilities. The three most common numerical types in Python are int for integers, float for floating-point numbers, and complex for complex numbers.\nLet‚Äôs start with a basic understanding of these number types:\n\nIntegers (int): These are positive or negative whole numbers with no decimal point. Integers in Python can be of any size, limited only by the amount of memory your system has.\n\n\n\nCode\na = 5\nb = -3\nc = 12345678901234567890  #Python 3 can handle very large integers.\n\n\n\nFloating-Point (float): These are real numbers (i.e., numbers that can have a decimal point). The float type in Python designates a floating-point number. Float values are specified with a decimal point. Optionally, the character e or E followed by a positive or negative integer may be appended to specify scientific notation.\n\n\n\nCode\na = 3.14159  # Pi to 5 decimal places.\nb = -0.01  # Negative float.\nc = 2.5e-4  # 2.5 times 10 to the power of -4.\n\n\n\nComplex (complex): Complex numbers are numbers with a real and an imaginary component. In Python, complex numbers can be created using the complex(real, imag) function, or you can use the ‚Äòj‚Äô suffix in a literal to specify the imaginary part.\n\n\n\nCode\na = complex(2, 3)  # 2 is the real part, 3 is the imaginary part.\nb = 3 + 4j  # Another way to create a complex number.\n\n\n\n\nNow, let‚Äôs illustrate some basic number theory concepts using these Python number types.\n\nEven and Odd Numbers: An integer is even if it is divisible by 2, and odd if it‚Äôs not.\n\n\n\nCode\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\nprint(is_even(4))  # True\nprint(is_odd(7))  # True\n\n\nTrue\nTrue\n\n\n\nPrime Numbers: A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n\n\n\nCode\ndef is_prime(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # True\nprint(is_prime(10))  # False\n\n\nTrue\nFalse\n\n\n\nIrrational Numbers: An irrational number cannot be expressed as a ratio between two numbers and it does not repeat periodically. One example is the number \\(\\pi\\) (pi), which Python can approximate with float. It‚Äôs important to remember that due to the limitations of representing real numbers in digital computers, certain mathematical properties might not hold exactly in computer arithmetic, especially with floating-point numbers.\n\n\n\nCode\nimport math\n\nprint(math.pi)  # 3.141592653589793\n\n\n3.141592653589793\n\n\nOne of the central themes in number theory is the study of prime numbers. A prime number is a positive integer greater than one that has no positive divisors other than one and itself. For example, 2, 3, 5, 7, 11, and 13 are all prime numbers. A positive integer that is not prime is called composite. The fundamental theorem of arithmetic states that every positive integer can be uniquely expressed as a product of primes. This means that there is only one way to write a positive integer as a product of primes, up to the order in which the factors are written.\nNumber theory has many practical applications, particularly in cryptography, which is the study of encoding messages to keep them secure from unauthorized access. Many encryption algorithms rely on the difficulty of factoring large composite numbers into primes, which is a problem that is believed to be computationally infeasible for sufficiently large integers. As a result, number theory plays a crucial role in the security of modern communication systems.\n\n\nCode\nimport time\n\ntic = time.time()\n\ndef find_factors(num): \n  factors = []\n  for i in range(1, num+1):\n    if num % i == 0:\n      factors.append(i) \n  return factors\n\ntic = time.time()\nprint(find_factors(12)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\n# print(find_factors(997*999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\n\n[1, 2, 3, 4, 6, 12]\n0.00037097930908203125 secs\n[1, 997]\n0.00013184547424316406 secs\n[1, 999983]\n0.059890031814575195 secs\n1.9073486328125e-05 secs\n\n\n\nAssignment: Make a short video explaining how factorization and prime numbers are used for encryption. Do proper research and use code demos.\nStretch: Expand your video with an exploration of the current state of quantum computing and it‚Äôs expected evolution. Discuss and illustrate the implications for current encryption methodologies. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "exponentslogs.html",
    "href": "exponentslogs.html",
    "title": "Exponents and Logarithms ü§î",
    "section": "",
    "text": "See book section and section\nExponents and Logarithms Explained\nUnderstanding exponents and logarithms is crucial for many scientific and financial applications.\nExponents: Exponents are mathematical operations that indicate the repeated multiplication of a base number by itself. The exponent, represented by a superscript, tells us how many times the base is multiplied by itself. Exponents are also known as powers. They play a fundamental role in mathematics and have many applications in various fields, including science, engineering, and finance.\n\n\nNotation: The general notation for expressing an exponent is:\n\\(a^b\\)\nWhere \\(a\\) is the base, and \\(b\\) is the exponent.\nExamples:\n\n\\(2^3 = 2 * 2 * 2 = 8\\)\n\\(5^2 = 5 * 5 = 25\\)\n\\(10^0 = 1\\) (Any number raised to the power of 0 is always 1)\n\\(3^{-2} = 1 / (3^2) = 1 / 9\\) (Negative exponents indicate the reciprocal of the base raised to the positive exponent)\n\nPython Code for Exponents: Python provides the double asterisk ** operator to calculate exponents.\n\n\nCode\n# Calculate 2 raised to the power of 3\nresult = 2 ** 3\nprint(result)  # Output: 8\n\n# Calculate 5 raised to the power of 2\nresult = 5 ** 2\nprint(result)  # Output: 25\n\n# Calculate 10 raised to the power of 0\nresult = 10 ** 0\nprint(result)  # Output: 1\n\n# Calculate 3 raised to the power of -2\nresult = 3 ** (-2)\nprint(result)  # Output: 0.1111111111111111\n\n\n8\n25\n1\n0.1111111111111111\n\n\nLogarithms: Logarithms are the inverse operations of exponents. They represent the power to which a given base must be raised to obtain a specific number. In simpler terms, logarithms answer the question: ‚ÄúWhat exponent should I raise the base to in order to get the desired number?‚Äù\n\n\nNotation: The general notation for expressing a logarithm is:\n\\(log_b(x)\\)\nWhere \\(b\\) is the base, and \\(x\\) is the number.\nExamples:\n\n\\(log_2(8) = 3\\) \\((since \\ 2^3 = 8)\\)\n\\(log_5(25) = 2\\) \\((since \\ 5^2 = 25)\\)\n\\(log_{10}(1) = 0\\) \\((since \\ 10^0 = 1)\\)\n\nPython Code for Logarithms: Python‚Äôs math module provides the log() function to calculate logarithms with a specified base.\n\n\nCode\nimport math\n\n# Calculate log base 2 of 8\nresult = math.log(8, 2)\nprint(result)  # Output: 3.0\n\n# Calculate log base 5 of 25\nresult = math.log(25, 5)\nprint(result)  # Output: 2.0\n\n# Calculate log base 10 of 1\nresult = math.log(1, 10)\nprint(result)  # Output: 0.0\n\n\n3.0\n2.0\n0.0\n\n\nPractical Examples: Exponents and logarithms are widely used in various real-world scenarios. Here are a couple of practical examples:\n1. Compound Interest: Compound interest calculations involve the use of exponents to determine the future value of an investment based on a given interest rate and time period.\n2. Data Scaling: In data analysis, data scaling is a preprocessing step used in data analysis to transform data to a similar scale. It helps avoid issues caused by having features with vastly different ranges. One common method of data scaling is using logarithms to scale down large numerical values.\nLet‚Äôs demonstrate data scaling with a Python code example using the numpy library for numerical operations and the matplotlib library for visualization.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Sample data with a wide range of values\ndata = np.array([1000, 200, 500, 15000, 300, 2500, 10000])\n\n# Apply data scaling using the natural logarithm (base e)\nscaled_data = np.log(data)\n\n# Plot original and scaled data\nplt.figure(figsize=(10, 5))\n\n# Plot original data\nplt.subplot(1, 2, 1)\nplt.plot(data, marker='o', linestyle='-', color='b')\nplt.xlabel('Data Point')\nplt.ylabel('Original Data')\nplt.title('Original Data')\n\n# Plot scaled data\nplt.subplot(1, 2, 2)\nplt.plot(scaled_data, marker='o', linestyle='-', color='g')\nplt.xlabel('Data Point')\nplt.ylabel('Scaled Data')\nplt.title('Scaled Data (Using Logarithm)')\n\nplt.tight_layout()\nplt.show()\n\n\n\n\n\nIn this example, we have an array data containing some sample data with a wide range of values. To scale the data, we apply the natural logarithm (base \\(e\\)) to each element of the array using np.log(). The resulting scaled_data array contains the scaled-down values.\nBy using logarithms for data scaling, we transform the data into a more manageable range, making it easier to visualize and analyze. Data scaling is particularly useful in situations where the range of values is large and can help improve the performance of machine learning models and statistical analyses.\nRelation with Summation\nA geometric series is a specific type of summation in which each term is found by multiplying the previous term by a constant factor. The general form of a geometric series is:\n\\(\\sum_{n=0}^{k} ar^n\\)\nWhere \\(a\\) is the first term, \\(r\\) is the common ratio between consecutive terms, and \\(n\\) is the index variable. Geometric series are commonly used in various mathematical and financial applications.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef geom_series(a, k):\n  summation = sum(a**i for i in range(0, k+1))\n  return summation\n\nr1 = 0.9\nr2 = 0.75\nr3 = 0.5\nx = np.arange(2, 100)\ny1 = np.array([geom_series(r1, k) for k in x])\ny2 = np.array([geom_series(r2, k) for k in x])\ny3 = np.array([geom_series(r3, k) for k in x])\nplt.clf()\nplt.plot(x, y1)\nplt.plot(x, y2)\nplt.plot(x, y3)\nplt.show()\n\n\n\n\n\nApplication in Valuation of Investments - Discounting Cash Flows:\nIn finance, summations and geometric series are utilized in discounted cash flow analysis to determine the present value of future cash flows, helping investors make informed decisions about their investments based on the time value of money. Discounted cash flow (DCF) analysis is a widely used method to determine the present value of future cash flows.\nWhen a constant series of cash flows is expected to be received in the future (e.g., an investment that generates fixed returns over time), we can represent it as a geometric series. However, since money received in the future is not as valuable as money received today (due to the time value of money), we need to discount these future cash flows to their present value using an appropriate discount rate.\nThe present value (PV) of a series of future cash flows can be calculated using the geometric series formula:\n\\[\nPV = C * (\\frac{1}{(1 + r)^1} + \\frac{1}{(1 + r)^2} + ... + \\frac{1}{(1 + r)^k})\n\\]\n\\[\n= C * \\sum_{n=1}^{k} \\frac{1}{(1 + r)^n}\n\\] \\[\n= C*\\frac{1-1/(1+r)^k}{r}\n\\]\nWhere: - \\(PV\\) is the present value of the cash flows. - \\(C\\) is the constant cash flow received each period. - \\(r\\) is the discount rate (expressed as a decimal). - \\(n\\) is the number of periods (the investment horizon).\nBy discounting future cash flows back to their present value, we can compare investments with different time frames or cash flow patterns and make informed investment decisions.\n\n\nCode\nr = 0.1\na = 1/(1+r)\nk = 5\na = geom_series(a, k) - 1\nb = (1-(1/(1+r)**5))/r\n\nprint(a, b)\n\n\n3.7907867694084487 3.7907867694084505\n\n\n\nAssignment: Make a short video explaining how geometric series are used in financial valuation (discounted cash flow method). Do proper research and use code demos.\nStretch: Expand your video with an example of valuing the stock of a listed company. Compare your result with the actual market price and discuss the differences. Illustrate with code examples and charts. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "Variables",
    "section": "",
    "text": "See book section\n\n\nRelationship Between Mathematical Variables and Variables in Python\nIn mathematics, variables are symbols that represent unknown quantities or values. They allow us to write equations and express relationships between different elements. Similarly, in programming, variables play a crucial role in storing and manipulating data. Python, as a programming language, allows us to work with variables in ways that have similarities to mathematical variables but also exhibit some distinct characteristics.\n1. Assigning Values to Variables:\nIn both mathematics and Python, variables need to be assigned values before they can be used. In Python, the assignment is done using the ‚Äú=‚Äù operator.\nExample: Python Variable\n\n\nCode\nx = 5\n\n\n2. Updating Values:\nIn mathematics, variables remain constant unless explicitly stated otherwise. In contrast, Python allows variables to be updated with new values during the course of a program.\nExample: Updating Python Variable\n\n\nCode\nx = 5\nx = x + 3  # The value of x is updated to 8\n\n\n3. Data Types:\nIn both mathematics and Python, variables can represent different types of data. In mathematics, variables are usually used to represent real or complex numbers. In Python, variables can hold a variety of data types, including integers, floating-point numbers, strings, lists, dictionaries, etc.\nExample: Different Data Types in Python\n\n\nCode\nx = 5  # Integer\ny = 3.14  # Floating-point number\nname = \"John\"  # String\ngrades = [90, 85, 95]  # List\nstudent_info = {\"name\": \"Alice\", \"age\": 25}  # Dictionary\n\n\n4. Mathematical Operations vs.¬†Python Operations:\nBoth mathematical and Python variables can be used in mathematical operations, but there are some differences in notation. For instance, in mathematics, multiplication is often denoted with the ‚Äúx‚Äù symbol, while in Python it is denoted by ‚Äú*‚Äú. However, the operators for addition, subtraction, and division are the same in both contexts.\nExample: Python Operations\n\n\nCode\nx = 5\ny = 3\n\nresult = 2 * x + y  # The result will be 13\n\n\n5. Variable Names:\nIn both mathematics and Python, variable names are used to refer to specific values. However, there are some restrictions on variable names in Python. They cannot start with a number, and they cannot contain spaces or special characters except for underscores.\nExample: Valid and Invalid Variable Names in Python\n\n\nCode\n# Valid variable names\nage = 25\nfirst_name = \"John\"\ninterest_rate = 0.05\n\n# Invalid variable names (due to starting with a number)\n2nd_place = \"Silver\"\n\n\nIn conclusion, the relationship between mathematical variables and variables in Python revolves around the concept of representing and working with data. Python‚Äôs variables offer greater flexibility as they can hold different data types and be updated during program execution. Understanding these similarities and differences is essential for effective programming in Python and for translating mathematical concepts into code."
  },
  {
    "objectID": "summations.html",
    "href": "summations.html",
    "title": "Summations",
    "section": "",
    "text": "See book section\n\n\nMathematical Concept of Summations:\nIn mathematics, summation is a concept that represents the addition of a sequence of numbers or terms. It is denoted by the symbol ‚ÄúŒ£‚Äù (sigma) and is used to express the total sum of a series of terms. The general form of a summation is:\n\\(\\sum_{n=1}^{k} f(n)\\)\nHere, \\(n\\) is the index variable that takes on values from 1 to \\(k\\) and \\(f(n)\\) is the function that defines the terms to be summed. The summation symbol indicates that we need to add up all the terms in the series for each value of \\(n\\).\nExample of Summation:\nLet‚Äôs consider the following example of a simple summation:\n\\(\\sum_{n=1}^{5} n\\)\nThis summation represents adding up all the integers from 1 to 5:\n1 + 2 + 3 + 4 + 5 = 15\nImplementing Summations in Python:\nIn Python, you can use loops to implement summations. The for loop is commonly used to iterate through a range of values and accumulate the sum.\nExample of Summation in Python:\n\n\nCode\n# Calculate the summation Œ£ (n = 1 to 5) n\ntotal_sum = 0\nfor n in range(1, 6):\n    total_sum += n\n\nprint(total_sum)  # Output: 15\n\n\n15"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Before starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O‚ÄôReilly Media, Inc.\na data science environment setup\n\nIn case you have not yet set up your environment you can use online notebook services like Google Colab or JupyterLab or Replit"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction",
    "section": "",
    "text": "Before starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O‚ÄôReilly Media, Inc.\na data science environment setup\n\nIn case you have not yet set up your environment you can use online notebook services like Google Colab or JupyterLab or Replit"
  },
  {
    "objectID": "index.html#purpose",
    "href": "index.html#purpose",
    "title": "Introduction",
    "section": "2 Purpose",
    "text": "2 Purpose\nThe general learning outcome of this course is:\n\nThe student is able to perform a well-defined task independently in a relatively clearly arranged situation, or is able to perform in a complex and unpredictable situation under supervision.\n\nAfter studying this course, you should be able to:\n\nRelate set theory to the concept of probability\n\n\n\nInterpret, modify and sketch mathematical operations\nCompute and solve mathematical equations\nCompute, manipulate, solve and plot mathematical functions\nUse Python or other data science script languages"
  },
  {
    "objectID": "index.html#content",
    "href": "index.html#content",
    "title": "Introduction",
    "section": "3 Content",
    "text": "3 Content\nIn weeks 1 and 2 you‚Äôll be learning the following topics (sections marked with ü§î contain assignments):\n\nNumber Theoryü§î\nOrder of Operationsü§î\nVariables\nFunctions\nSummations\nExponents and Logarithmsü§î\nEuler‚Äôs Number and Natural Logarithms\n\nEuler‚Äôs Number\nNatural Logarithms\n\nLimits\nDerivatives\n\nPartial Derivatives\nThe Chain Rule\n\nIntegrals"
  },
  {
    "objectID": "integrals.html",
    "href": "integrals.html",
    "title": "Integrals ü§î",
    "section": "",
    "text": "See book section\n\n\nIntegrals in calculus can be a challenging concept to grasp, but they can also be a powerful tool for solving various problems in business management and engineering. Integrals can be used to calculate quantities such as total cost, total revenue, and consumer surplus, among others. They are also essential in modeling and analyzing time-dependent phenomena in financial markets, operations management, logistics, and so on.\nUnderstanding Integrals\nIn simple terms, an integral can be seen as the ‚Äúopposite‚Äù of a derivative. If a derivative gives you the rate of change at a certain point, an integral gives you the total accumulation over a certain range.\nImagine you own a factory, and you produce goods at a certain rate per day. This production rate can vary from day to day. If you wanted to know the total goods produced in a month, you could sum up the daily production rates. In the world of calculus, this summing process is analogous to an integral.\nNow, let‚Äôs illustrate the concept of the integral using Python. We‚Äôll use the library scipy, which provides functions for numerical integration. First, let‚Äôs define a simple function to represent the rate of goods production per day.\n\n\nCode\nimport numpy as np\nfrom scipy.integrate import quad\nimport matplotlib.pyplot as plt\n\n# This is our production rate function\ndef production_rate(t):\n    return (100 + 30*np.sin(t))\n\nt = np.linspace(0, 30, 300)\nft = production_rate(t)\ng = np.zeros(ft.shape)\n\nplt.close()\nplt.xlim(0, 35)\nplt.ylim(0, 135)\nplt.plot(t, ft)\nplt.show()\n\n\n\n\n\nThe function production_rate(t) is a somewhat arbitrary function representing the rate of goods production for each day t. It‚Äôs assumed that the production rate varies in a sinusoidal manner around a baseline of 100 units/day, to mimic the variations in production you might encounter in a real factory.\nNow, we can compute the total goods produced over a month (let‚Äôs approximate a month as 30 days). We use the quad function from scipy.integrate, which performs numerical integration.\n\n\nCode\nplt.close()\nplt.xlim(0, 35)\nplt.ylim(0, 135)\nplt.plot(t, ft, t, g)\nplt.fill_between(t, ft, g, color=\"tomato\")\nplt.show()\n\ntotal_production, error = quad(production_rate, 0, 30)\n\nprint(f'Total production over 30 days: {total_production} units')\n\n\n\n\n\nTotal production over 30 days: 3025.3724565033726 units\n\n\nReal-World Applications\n1. Economics and Finance: Integrals are used in economics and finance to calculate areas under curves. For instance, in a supply and demand graph, the area between the supply and demand curves up to the market price line is called the consumer surplus, which can be calculated using integrals. Similarly, the area under a company‚Äôs revenue or cost function gives the total revenue or total cost, respectively.\n2. Operations Management: In the field of operations management, integrals can be used to model and analyze continuous production processes. If a factory‚Äôs production rate is represented by a function of time, the integral of that function over a given time period gives the total production.\n3. Logistics: In logistics and supply chain management, integrals can be used to calculate total transportation costs, total inventory held over time, and other cumulative quantities.\nIn summary, while calculus and specifically integrals might seem daunting, they are fundamental mathematical tools in various business scenarios. Understanding how they work and being able to apply them can be a valuable asset for a business management professional.\nAbsolutely! Let‚Äôs explore how integrals can be used in the fields of engineering and software development.\n4. Civil Engineering: Civil engineers use integrals when calculating the load distribution on beams, the moment of inertia, and when determining the stress and strain on various materials.\nFor example, to calculate the center of mass of an irregularly shaped object, engineers would use calculus and specifically the concept of integration.\n\n\nCode\nimport numpy as np\nfrom scipy.integrate import quad\n\n# Assume an object's mass distribution along the x-axis is given by the function:\ndef mass_distribution(x):\n    return x**2 + 3*x + 1  # Arbitrary function for illustrative purposes.\n\n# We want to find the center of mass of this object over the interval from 0 to 2 meters.\nx_values = np.linspace(0, 2, 100)\nmass_values = mass_distribution(x_values)\n\n# Calculate total mass:\ntotal_mass, _ = quad(mass_distribution, 0, 2)\n\n# Now calculate x-coordinate of the center of mass:\ndef integrand(x):\n    return x * mass_distribution(x)  # This is x * dm(x).\n\ncenter_of_mass, _ = quad(integrand, 0, 2)\ncenter_of_mass /= total_mass\n\nprint(f'Center of mass: {center_of_mass} m')\n\n\nCenter of mass: 1.3125 m\n\n\n5. Computer Graphics: Integrals are used extensively in computer graphics, especially in rendering. When calculating the lighting of a point, we would integrate over all possible light paths that can reach the point. This is the basis for techniques like ray tracing and radiosity.\n6. Machine Learning: Many machine learning algorithms, especially those in deep learning, involve optimization of continuous functions. The process of training a neural network, for instance, involves performing gradient descent on the cost function, which is an integral over the entire training set.\n7. Algorithm Analysis: Integrals can be used to analyze algorithms that work with continuous data or where the performance of the algorithm changes continuously with the input size. An integral can provide the average case performance of such an algorithm.\nThese are just some examples. The applications of integrals are vast and extend to many other fields like electrical engineering, mechanical engineering, aerospace, and even in theoretical computer science and algorithm analysis. Understanding how to apply the concept of integrals can thus provide a solid foundation for problem-solving in these disciplines.\n\n\\({f(x)={\\frac {1}{\\sigma {\\sqrt {2\\pi }}}}e^{-{\\frac {1}{2}}\\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}}}\\)\n\n\nCode\nfrom sympy import *\nimport math\nimport numpy as np\n\ndef approximate_integral(a, b, n, f):\n    delta_x = (b - a) / n\n    total_sum = 0\n\n    for i in range(1, n + 1):\n        midpoint = 0.5 * (2 * a + delta_x * (2 * i - 1))\n        total_sum += f(midpoint)\n\n    return total_sum * delta_x\n\ndef my_function(x, mu=0, sigma=1):\n    l = 1/(sigma*(2*math.pi)**0.5)\n    r = -0.5*((x - mu) / sigma)**2\n    return l*exp(r)\n\na=-1\nb=1\nx = symbols('x')\nf = my_function(x)\nx_area = np.linspace(a, b, 1000)\nf_area = lambdify(x, f)(x_area)\nplot(f, xlim=(-5, 5), fill={'x': x_area,'y1':f_area,'color':'tomato'})\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x126afd1c0&gt;\n\n\n\n\nCode\ndef integral_function(x):\n    mu = 0\n    sigma = 1\n    return(my_function(x, mu, sigma))\n  \narea = approximate_integral(a=-1, b=1, n=1000, f=integral_function)\n\nprint(area) # prints \n\n\n0.682689572794013\n\n\nAssignment: Make a short video discussing the relationship between integrals and statistics.\nStretch: Expand your video showcasing the various applications related to your field of study.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  }
]