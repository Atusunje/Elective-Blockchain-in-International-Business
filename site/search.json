[
  {
    "objectID": "integrals.html",
    "href": "integrals.html",
    "title": "Integrals ü§î",
    "section": "",
    "text": "See book section\nIntegrals in calculus can be a challenging concept to grasp, but they can also be a powerful tool for solving various problems in business management and engineering. Integrals can be used to calculate quantities such as total cost, total revenue, and consumer surplus, among others. They are also essential in modeling and analyzing time-dependent phenomena in financial markets, operations management, logistics, and so on.\nUnderstanding Integrals\nIn simple terms, an integral can be seen as the ‚Äúopposite‚Äù of a derivative. If a derivative gives you the rate of change at a certain point, an integral gives you the total accumulation over a certain range.\nImagine you own a factory, and you produce goods at a certain rate per day. This production rate can vary from day to day. If you wanted to know the total goods produced in a month, you could sum up the daily production rates. In the world of calculus, this summing process is analogous to an integral.\nNow, let‚Äôs illustrate the concept of the integral using Python. We‚Äôll use the library scipy, which provides functions for numerical integration. First, let‚Äôs define a simple function to represent the rate of goods production per day.\nCode\nimport numpy as np\nfrom scipy.integrate import quad\nimport matplotlib.pyplot as plt\n\n# This is our production rate function\ndef production_rate(t):\n    return (100 + 30*np.sin(t))\n\nt = np.linspace(0, 30, 300)\nft = production_rate(t)\ng = np.zeros(ft.shape)\n\nplt.close()\nplt.xlim(0, 35)\nplt.ylim(0, 135)\nplt.plot(t, ft)\nplt.show()\nThe function production_rate(t) is a somewhat arbitrary function representing the rate of goods production for each day t. It‚Äôs assumed that the production rate varies in a sinusoidal manner around a baseline of 100 units/day, to mimic the variations in production you might encounter in a real factory.\nNow, we can compute the total goods produced over a month (let‚Äôs approximate a month as 30 days). We use the quad function from scipy.integrate, which performs numerical integration.\nCode\nplt.close()\nplt.xlim(0, 35)\nplt.ylim(0, 135)\nplt.plot(t, ft, t, g)\nplt.fill_between(t, ft, g, color=\"tomato\")\nplt.show()\n\ntotal_production, error = quad(production_rate, 0, 30)\n\nprint(f'Total production over 30 days: {total_production} units')\n\n\n\n\n\nTotal production over 30 days: 3025.3724565033726 units\nReal-World Applications\n1. Economics and Finance: Integrals are used in economics and finance to calculate areas under curves. For instance, in a supply and demand graph, the area between the supply and demand curves up to the market price line is called the consumer surplus, which can be calculated using integrals. Similarly, the area under a company‚Äôs revenue or cost function gives the total revenue or total cost, respectively.\n2. Operations Management: In the field of operations management, integrals can be used to model and analyze continuous production processes. If a factory‚Äôs production rate is represented by a function of time, the integral of that function over a given time period gives the total production.\n3. Logistics: In logistics and supply chain management, integrals can be used to calculate total transportation costs, total inventory held over time, and other cumulative quantities.\n4. Civil Engineering: Civil engineers use integrals when calculating the load distribution on beams, the moment of inertia, and when determining the stress and strain on various materials.\nFor example, to calculate the center of mass of an irregularly shaped object, engineers would use calculus and specifically the concept of integration.\nCode\nfrom sympy import *\n\n# Assume an object's mass distribution along the x-axis is given by the function:\ndef mass_distribution(x):\n    return x**2 + 6*x + 9  # Arbitrary function for illustrative purposes.\n\n# We want to find the center of mass of this object over the interval from 0 to 2 meters.\nx_values = np.linspace(0, 2, 100)\nmass_values = mass_distribution(x_values)\n\nx = symbols('x')\nf = mass_distribution(x)\nx_area = np.linspace(0, 2, 100)\nf_area = lambdify(x, f)(x_area)\nplot(f, xlim=(-5, 5), ylim=(0, 80), fill={'x': x_area,'y1':f_area,'color':'tomato'})\n\n# Calculate total mass:\ntotal_mass, _ = quad(mass_distribution, 0, 2)\n\n# Now calculate x-coordinate of the center of mass:\ndef integrand(x):\n    return x * mass_distribution(x)  # This is x * dm(x).\n\ncenter_of_mass, _ = quad(integrand, 0, 2)\ncenter_of_mass /= total_mass\n\nprint(f'Center of mass: {center_of_mass} m')\n\n\n\n\n\nCenter of mass: 1.1632653061224485 m\n5. Computer Graphics: Integrals are used extensively in computer graphics, especially in rendering. When calculating the lighting of a point, we would integrate over all possible light paths that can reach the point. This is the basis for techniques like ray tracing and radiosity.\n6. Machine Learning: Many machine learning algorithms, especially those in deep learning, involve optimization of continuous functions. The process of training a neural network, for instance, involves performing gradient descent on the cost function, which is an integral over the entire training set.\n7. Algorithm Analysis: Integrals can be used to analyze algorithms that work with continuous data or where the performance of the algorithm changes continuously with the input size. An integral can provide the average case performance of such an algorithm.\nThese are just some examples. The applications of integrals are vast and extend to many other fields like electrical engineering, mechanical engineering, aerospace, and even in theoretical computer science and data science. Understanding how to apply the concept of integrals can thus provide a solid foundation for problem-solving in these disciplines."
  },
  {
    "objectID": "integrals.html#assignment",
    "href": "integrals.html#assignment",
    "title": "Integrals ü§î",
    "section": "Assignment",
    "text": "Assignment\n\\({f(x)={\\frac {1}{\\sigma {\\sqrt {2\\pi }}}}e^{-{\\frac {1}{2}}\\left({\\frac {x-\\mu }{\\sigma }}\\right)^{2}}}\\)\n\n\nCode\nimport math\n\ndef approximate_integral(a, b, n, f):\n    delta_x = (b - a) / n\n    total_sum = 0\n\n    for i in range(1, n + 1):\n        midpoint = 0.5 * (2 * a + delta_x * (2 * i - 1))\n        total_sum += f(midpoint)\n\n    return total_sum * delta_x\n\ndef my_function(x, mu=0, sigma=1):\n    l = 1/(sigma*(2*math.pi)**0.5)\n    r = -0.5*((x - mu) / sigma)**2\n    return l*exp(r)\n\na=-1\nb=1\nx = symbols('x')\nf = my_function(x)\nx_area = np.linspace(a, b, 1000)\nf_area = lambdify(x, f)(x_area)\nplot(f, xlim=(-4, 4), fill={'x': x_area,'y1':f_area,'color':'tomato'})\n\ndef integral_function(x):\n    mu = 0\n    sigma = 1\n    return(my_function(x, mu, sigma))\n  \narea = approximate_integral(a=a, b=b, n=1000, f=integral_function)\n\nprint(area) # prints \n\n\n\n\n\n0.682689572794013\n\n\nBasic: Make a short video discussing the relationship between integrals and statistics.\nStretch: Expand your video showcasing the various applications related to your field of study.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "derivatives.html",
    "href": "derivatives.html",
    "title": "Derivatives ü§î",
    "section": "",
    "text": "See book section\nIn mathematics, the derivative is a fundamental concept in calculus, describing the rate of change of a function at a particular point. Essentially, it gives you the ‚Äúslope‚Äù of the function at that point. The concepts of partial derivatives and chain rule further extend this foundational concept.\nBasic Understanding\nThe derivative of a function \\(f(x)\\) is given by the limit:\n\\(f'(x) = \\mathop {\\lim }\\limits_{h \\to 0} \\frac{f(x + h) - f(x)}{h}\\)\nIn Python, we can approximate this as follows:\nCode\ndef derivative(f, x, h=0.00001):\n    return (f(x + h) - f(x)) / h\nThis function can be used to find the derivative of a function at a given point. For example, if you have a function \\(f(x) = x^2\\), you can find the derivative at \\(x=2\\) like so:\nCode\ndef f(x):\n    return x**2\n\nprint(derivative(f, 2))  # Output: 4.00001\n\n\n4.000010000027032\nThe derivative of \\(x^2\\) is \\(2x\\), so at \\(x=2\\), the derivative is \\(4\\). The output \\(4.00001\\) is slightly higher due to the approximation.\nPartial Derivatives\nA partial derivative is like a normal derivative but it‚Äôs used for functions with more than one variable. We consider one variable at a time and treat all other variables as constants.\nFor example, consider the function \\(f(x, y) = x^2 + y^2\\). The partial derivative of \\(f\\) with respect to \\(x\\) (denoted as \\(\\frac{\\partial f}{\\partial x}\\)) is \\(2x\\), and the partial derivative with respect to \\(y\\) (denoted as \\(\\frac{\\partial f}{\\partial y}\\)) is \\(2y\\).\nIn Python, you can approximate these as follows:\nCode\ndef partial_derivative(f, x, y, h=0.00001):\n    df_dx = (f(x + h, y) - f(x, y)) / h\n    df_dy = (f(x, y + h) - f(x, y)) / h\n    return df_dx, df_dy\n\ndef f(x, y):\n    return x**2 + y**2\n\nprint(partial_derivative(f, 2, 3))  # Output: (4.00001, 6.00001)\n\n\n(4.000010000027032, 6.000009999951316)\nChain Rule\nThe chain rule is a principle in calculus used to compute the derivative of a composition of functions. If you have a function composed of several other functions, the derivative of the overall function is the product of the derivatives of the component functions.\nFor example, if \\(y = f(g(h(x)))\\), then \\(dy/dx = f'(g(h(x))) * g'(h(x)) * h'(x)\\).\nConsider the function \\(f(x) = (3x + 1)^2\\). Here, \\(f(x)\\) is a composition of \\(u(x) = 3x + 1\\) and \\(v(u) = u^2\\).\nUsing the chain rule to find the derivative:\nCode\ndef f(x):\n    return (3*x + 1)**2\n\ndef df(x):\n    return 2 * (3*x + 1) * 3\n\nprint(df(2))  # Output: 42\n\n\n42\nWe found \\(df/dx = 2*(3x+1)*3\\) by applying the chain rule: derivative of \\(v(u) = u^2\\) is \\(2*u\\), and derivative of \\(u(x) = 3x + 1\\) is \\(3\\). Thus, the derivative of \\(f(x) = (3x + 1)^2\\) is \\(2*(3x+1)*3\\).\nSo, the derivative of the function at \\(x=2\\) is \\(42\\).\nReal World Applications\n1. Business Management\nIn business management, derivatives can be used to optimize profit. Assume we have a function representing the profit of a company as a function of the price, \\(f(p)\\). The derivative \\(f'(p)\\) gives the rate of change of profit with respect to the price. If \\(f'(p) &gt; 0\\), producing more units will increase profit, if \\(f'(p) &lt; 0\\), producing more will decrease profit, and if \\(f'(p) = 0\\), we‚Äôve reached a maximum or minimum point.\nTake for instance the function \\(f(p) = -p^2 + 20p\\).\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef profit(p):\n    return -p**2 + 20*p\n\nprices = np.linspace(0, 20, 400)\nprofits = profit(prices)\n\nplt.plot(prices, profits)\nplt.title('Profit vs. Price')\nplt.xlabel('Price')\nplt.ylabel('Profit')\nplt.grid(True)\nplt.show()\nTo find the price level that maximizes profits, we first obtain the derivative function \\(f'(p) = -2p + 20\\), solve the equation \\(-2p + 20 = 0\\) and check that the optimal price level \\(p = 10\\) results in a profit of \\(-(10^2) + 20 * 10 = 100\\).\nCode\nprint(derivative(profit, 10))  # Output: almost zero\n\n\n-9.99875737761613e-06\n2. Engineering\nIn engineering, derivatives are used in areas like dynamics, control systems, and signal processing. For instance, in mechanical engineering, the velocity of an object is the derivative of the object‚Äôs position with respect to time.\n3. Data Science\nIn data science, derivatives play a critical role in optimization algorithms, such as Gradient Descent used in Machine Learning. The derivative is used to determine the direction to move in the parameter space to minimize a given cost function.\nFor example, consider a simple linear regression model with one variable. The cost function \\(J(m, b)\\) for a given slope \\(m\\) and intercept \\(b\\) can be defined as the mean squared error (MSE) between the predicted and actual values. We can use gradient descent to find the \\(m\\) and \\(b\\) that minimize \\(J(m, b)\\), where the derivatives \\(‚àÇJ/‚àÇm\\) and \\(‚àÇJ/‚àÇb\\) guide the updating process."
  },
  {
    "objectID": "derivatives.html#assignment",
    "href": "derivatives.html#assignment",
    "title": "Derivatives ü§î",
    "section": "Assignment",
    "text": "Assignment\nBasic: Make a short video explaining illustrating the functioning of the chain rule. Start by demonstrating that \\((a + b)^2 = a^2 + 2ab + b^2\\). For example \\((x + 3)^2 = x^2 + 6x + 9\\). Use code examples and plots. HINT: revisit the section on functions\nStretch: Make another video discussing the Gradient Descent algorithm. Implement the algorithm for a simple linear regression model with one variable. The dataset for the assignment is as follows:\n\n\nCode\nimport numpy as np\n\n# Generate some sample data\nnp.random.seed(0)\nx = np.random.rand(100, 1)\ny = 2 + 3 * x + np.random.rand(100, 1)\n\n\nYour task is to predict \\(y\\) from \\(x\\) by minimizing the MSE cost function using Gradient Descent. Find the optimal values of \\(m\\) and \\(b\\) and plot the regression line on a scatter plot of \\(y\\) versus \\(x\\).\nRemember to start with an initial guess for your parameters (e.g., \\(m = 0, \\ b = 0\\)) and update them iteratively using the Gradient Descent update rules:\n\\(m = m - Œ± * ‚àÇJ/‚àÇm\\)\n\\(b = b - Œ± * ‚àÇJ/‚àÇb\\)\nWhere \\(Œ±\\) is the learning rate.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction to Math and Stats",
    "section": "",
    "text": "Prerequisites\n\n\n\n\n\n\nBefore starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O‚ÄôReilly Media, Inc.\na data science environment setup\n\nIn case you have not yet set up your environment you can use online notebook services like Google Colab or JupyterLab or Replit\n\n\nPurpose\nThe general learning outcome of this course is:\n\nThe student is able to perform a well-defined task independently in a relatively clearly arranged situation, or is able to perform in a complex and unpredictable situation under supervision.\n\nAfter studying this course, you should be able to:\n\nRelate set theory to the concept of probability\n\n\n\nInterpret, modify and sketch mathematical operations\nCompute and solve mathematical equations\nCompute, manipulate, solve and plot mathematical functions\nUse Python or other data science script languages\n\nContent\nThe course will cover the following topics.\n\nBasic Math and CalculusProbablityDescriptive StatisticsInferential Statistics\n\n\nIn weeks 1 and 2 you‚Äôll be learning the following topics (sections marked with ü§î contain assignments):\n\nNumber Theoryü§î\nOrder of Operationsü§î\nVariables\nFunctions\nSummations\nExponents and Logarithmsü§î\nLimits\nDerivativesü§î\nEuler‚Äôs Number and Natural Logarithms\nIntegralsü§î\n\n\n\nIn week 3 you‚Äôll learn basic probability theory.\n\n\n\n\n\nIn week 4 you‚Äôll learn to uncover underlying patterns and trends utilizing inferential statistics.\n\n\n\n\n\nIn week 5 you‚Äôll learn to discover basic patterns and trends using inferential statistics."
  },
  {
    "objectID": "summations.html",
    "href": "summations.html",
    "title": "Summations",
    "section": "",
    "text": "See book section\n\n\n\n\n\nMathematical Concept of Summations:\nIn mathematics, summation is a concept that represents the addition of a sequence of numbers or terms. It is denoted by the symbol ‚ÄúŒ£‚Äù (sigma) and is used to express the total sum of a series of terms. The general form of a summation is:\n\\(\\sum_{n=1}^{k} f(n)\\)\nHere, \\(n\\) is the index variable that takes on values from 1 to \\(k\\) and \\(f(n)\\) is the function that defines the terms to be summed. The summation symbol indicates that we need to add up all the terms in the series for each value of \\(n\\).\nExample of Summation:\nLet‚Äôs consider the following example of a simple summation:\n\\(\\sum_{n=1}^{5} n\\)\nThis summation represents adding up all the integers from 1 to 5:\n1 + 2 + 3 + 4 + 5 = 15\nImplementing Summations in Python:\nIn Python, you can use loops to implement summations. The for loop is commonly used to iterate through a range of values and accumulate the sum.\nExample of Summation in Python:\n\n\nCode\n# Calculate the summation Œ£ (n = 1 to 5) n\ntotal_sum = 0\nfor n in range(1, 6):\n    total_sum += n\n\nprint(total_sum)  # Output: 15\n\n\n15"
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "Variables",
    "section": "",
    "text": "See book section\n\n\n\n\n\nRelationship Between Mathematical Variables and Variables in Python\nIn mathematics, variables are symbols that represent unknown quantities or values. They allow us to write equations and express relationships between different elements. Similarly, in programming, variables play a crucial role in storing and manipulating data. Python, as a programming language, allows us to work with variables in ways that have similarities to mathematical variables but also exhibit some distinct characteristics.\n1. Assigning Values to Variables:\nIn both mathematics and Python, variables need to be assigned values before they can be used. In Python, the assignment is done using the ‚Äú=‚Äù operator.\nExample: Python Variable\n\n\nCode\nx = 5\n\n\n2. Updating Values:\nIn mathematics, variables remain constant unless explicitly stated otherwise. In contrast, Python allows variables to be updated with new values during the course of a program.\nExample: Updating Python Variable\n\n\nCode\nx = 5\nx = x + 3  # The value of x is updated to 8\n\n\n3. Data Types:\nIn both mathematics and Python, variables can represent different types of data. In mathematics, variables are usually used to represent real or complex numbers. In Python, variables can hold a variety of data types, including integers, floating-point numbers, strings, lists, dictionaries, etc.\nExample: Different Data Types in Python\n\n\nCode\nx = 5  # Integer\ny = 3.14  # Floating-point number\nname = \"John\"  # String\ngrades = [90, 85, 95]  # List\nstudent_info = {\"name\": \"Alice\", \"age\": 25}  # Dictionary\n\n\n4. Mathematical Operations vs.¬†Python Operations:\nBoth mathematical and Python variables can be used in mathematical operations, but there are some differences in notation. For instance, in mathematics, multiplication is often denoted with the ‚Äúx‚Äù symbol, while in Python it is denoted by ‚Äú*‚Äù. However, the operators for addition, subtraction, and division are the same in both contexts.\nExample: Python Operations\n\n\nCode\nx = 5\ny = 3\n\nresult = 2 * x + y  # The result will be 13\n\n\n5. Variable Names:\nIn both mathematics and Python, variable names are used to refer to specific values. However, there are some restrictions on variable names in Python. They cannot start with a number, and they cannot contain spaces or special characters except for underscores.\nExample: Valid and Invalid Variable Names in Python\n\n\nCode\n# Valid variable names\nage = 25\nfirst_name = \"John\"\ninterest_rate = 0.05\n\n# Invalid variable names (due to starting with a number)\n2nd_place = \"Silver\"\n\n\nIn conclusion, the relationship between mathematical variables and variables in Python revolves around the concept of representing and working with data. Python‚Äôs variables offer greater flexibility as they can hold different data types and be updated during program execution. Understanding these similarities and differences is essential for effective programming in Python and for translating mathematical concepts into code."
  },
  {
    "objectID": "exponentslogs.html",
    "href": "exponentslogs.html",
    "title": "Exponents and Logarithms ü§î",
    "section": "",
    "text": "See book section and section\nExponents and Logarithms Explained\nUnderstanding exponents and logarithms is crucial for many scientific and financial applications.\nExponents: Exponents are mathematical operations that indicate the repeated multiplication of a base number by itself. The exponent, represented by a superscript, tells us how many times the base is multiplied by itself. Exponents are also known as powers. They play a fundamental role in mathematics and have many applications in various fields, including science, engineering, and finance.\nNotation: The general notation for expressing an exponent is:\n\\(a^b\\)\nWhere \\(a\\) is the base, and \\(b\\) is the exponent.\nExamples:\nPython Code for Exponents: Python provides the double asterisk ** operator to calculate exponents.\nCode\n# Calculate 2 raised to the power of 3\nresult = 2 ** 3\nprint(result)  # Output: 8\n\n# Calculate 5 raised to the power of 2\nresult = 5 ** 2\nprint(result)  # Output: 25\n\n# Calculate 10 raised to the power of 0\nresult = 10 ** 0\nprint(result)  # Output: 1\n\n# Calculate 3 raised to the power of -2\nresult = 3 ** (-2)\nprint(result)  # Output: 0.1111111111111111\n\n\n8\n25\n1\n0.1111111111111111\nLogarithms: Logarithms are the inverse operations of exponents. They represent the power to which a given base must be raised to obtain a specific number. In simpler terms, logarithms answer the question: ‚ÄúWhat exponent should I raise the base to in order to get the desired number?‚Äù\nNotation: The general notation for expressing a logarithm is:\n\\(log_b(x)\\)\nWhere \\(b\\) is the base, and \\(x\\) is the number.\nExamples:\nPython Code for Logarithms: Python‚Äôs math module provides the log() function to calculate logarithms with a specified base.\nCode\nimport math\n\n# Calculate log base 2 of 8\nresult = math.log(8, 2)\nprint(result)  # Output: 3.0\n\n# Calculate log base 5 of 25\nresult = math.log(25, 5)\nprint(result)  # Output: 2.0\n\n# Calculate log base 10 of 1\nresult = math.log(1, 10)\nprint(result)  # Output: 0.0\n\n\n3.0\n2.0\n0.0\nPractical Examples: Exponents and logarithms are widely used in various real-world scenarios. Here are a couple of practical examples:\n1. Compound Interest: Compound interest calculations involve the use of exponents to determine the future value of an investment based on a given interest rate and time period.\n2. Data Scaling: In data analysis, data scaling is a preprocessing step used in data analysis to transform data to a similar scale. It helps avoid issues caused by having features with vastly different ranges. One common method of data scaling is using logarithms to scale down large numerical values.\nLet‚Äôs demonstrate data scaling with a Python code example using the numpy library for numerical operations and the matplotlib library for visualization.\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Sample data with a wide range of values\ndata = np.array([1000, 200, 500, 15000, 300, 2500, 10000])\n\n# Apply data scaling using the natural logarithm (base e)\nscaled_data = np.log(data)\n\n# Plot original and scaled data\nplt.figure(figsize=(10, 5))\n\n# Plot original data\nplt.subplot(1, 2, 1)\nplt.plot(data, marker='o', linestyle='-', color='b')\nplt.xlabel('Data Point')\nplt.ylabel('Original Data')\nplt.title('Original Data')\n\n# Plot scaled data\nplt.subplot(1, 2, 2)\nplt.plot(scaled_data, marker='o', linestyle='-', color='g')\nplt.xlabel('Data Point')\nplt.ylabel('Scaled Data')\nplt.title('Scaled Data (Using Logarithm)')\n\nplt.tight_layout()\nplt.show()\nIn this example, we have an array data containing some sample data with a wide range of values. To scale the data, we apply the natural logarithm (base \\(e\\)) to each element of the array using np.log(). The resulting scaled_data array contains the scaled-down values.\nBy using logarithms for data scaling, we transform the data into a more manageable range, making it easier to visualize and analyze. Data scaling is particularly useful in situations where the range of values is large and can help improve the performance of machine learning models and statistical analyses.\nRelation with Summation\nA geometric series is a specific type of summation in which each term is found by multiplying the previous term by a constant factor. The general form of a geometric series is:\n\\(\\sum_{n=0}^{k} ar^n\\)\nWhere \\(a\\) is the first term, \\(r\\) is the common ratio between consecutive terms, and \\(n\\) is the index variable. Geometric series are commonly used in various mathematical and financial applications.\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef geom_series(a, k):\n  summation = sum(a**i for i in range(0, k+1))\n  return summation\n\nr1 = 0.9\nr2 = 0.75\nr3 = 0.5\nx = np.arange(2, 100)\ny1 = np.array([geom_series(r1, k) for k in x])\ny2 = np.array([geom_series(r2, k) for k in x])\ny3 = np.array([geom_series(r3, k) for k in x])\nplt.clf()\nplt.plot(x, y1)\nplt.plot(x, y2)\nplt.plot(x, y3)\nplt.show()\nApplication in Valuation of Investments - Discounting Cash Flows:\nIn finance, summations and geometric series are utilized in discounted cash flow analysis to determine the present value of future cash flows, helping investors make informed decisions about their investments based on the time value of money. Discounted cash flow (DCF) analysis is a widely used method to determine the present value of future cash flows.\nWhen a constant series of cash flows is expected to be received in the future (e.g., an investment that generates fixed returns over time), we can represent it as a geometric series. However, since money received in the future is not as valuable as money received today (due to the time value of money), we need to discount these future cash flows to their present value using an appropriate discount rate.\nThe present value (PV) of a series of future cash flows can be calculated using the geometric series formula:\n\\[\nPV = C * (\\frac{1}{(1 + r)^1} + \\frac{1}{(1 + r)^2} + ... + \\frac{1}{(1 + r)^k})\n\\]\n\\[\n= C * \\sum_{n=1}^{k} \\frac{1}{(1 + r)^n}\n\\] \\[\n= C*\\frac{1-1/(1+r)^k}{r}\n\\]\nWhere:\nBy discounting future cash flows back to their present value, we can compare investments with different time frames or cash flow patterns and make informed investment decisions.\nCode\nr = 0.1\na = 1/(1+r)\nk = 5\na = geom_series(a, k) - 1\nb = (1-(1/(1+r)**5))/r\n\nprint(a, b)\n\n\n3.7907867694084487 3.7907867694084505"
  },
  {
    "objectID": "exponentslogs.html#assignment",
    "href": "exponentslogs.html#assignment",
    "title": "Exponents and Logarithms ü§î",
    "section": "Assignment",
    "text": "Assignment\nBasic: Make a short video explaining how geometric series are used in financial valuation (discounted cash flow method). Do proper research and use code demos.\nStretch: Expand your video with an example of valuing the stock of a listed company. Compare your result with the actual market price and discuss the differences. Illustrate with code examples and charts. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "euler.html",
    "href": "euler.html",
    "title": "Euler‚Äôs Number and Natural Logarithms ü§î",
    "section": "",
    "text": "See book section\nIntroduction\nEuler‚Äôs number, often denoted as \\(e\\), is an irrational number roughly equal to 2.71828. It might sound abstract, but it plays a vital role in mathematics, particularly when dealing with exponential growth or decay, and in concepts of continuous compounding in finance.\nThe natural logarithm, usually represented as \\(\\ln\\), is the logarithm to the base \\(e\\). It‚Äôs fundamental in various fields, from solving exponential equations to analyzing exponential growth or decay patterns in data science.\nEuler‚Äôs Number (\\(e\\))\nEuler‚Äôs number arises naturally in many areas of mathematics. For instance, consider money that is being continuously compounded. If you were to compound $1 at 100% interest over a year, but compound more frequently (daily, hourly, every second, and so on), the amount you‚Äôd have with continuous compounding is \\(e\\) dollars.\nNatural Logarithm (\\(\\ln\\))\nThe natural logarithm is the inverse operation to exponentiation with base \\(e\\). In other words, if \\(y = e^x\\), then \\(x = \\ln(y)\\).\nWhy are they Important?\nCode Example in Python\nLet‚Äôs look at a real-world scenario:\nImagine a startup company‚Äôs user base grows continuously. In its initial stages, the number of users doubled every year. We can model this growth with the equation: \\(N(t) = N_0 \\times e^{kt}\\) Where:\nGiven that the users doubled every year, we can determine \\(k\\).\nCode\nimport numpy as np\n\n# Given values\nN_0 = 100  # Initial number of users\nN_t = 200  # Number of users after 1 year\n\n# Finding k using natural logarithm\nk = np.log(N_t/N_0)\n\nprint(f\"With growth constant k = {k} the number of users after 2 years = 100*e^(k*2) = {100*np.exp(k*2)}\")\n\n\nWith growth constant k = 0.6931471805599453 the number of users after 2 years = 100*e^(k*2) = 400.0\nUsing this growth constant, a company can predict future user numbers and strategize its business operations accordingly."
  },
  {
    "objectID": "euler.html#assignment",
    "href": "euler.html#assignment",
    "title": "Euler‚Äôs Number and Natural Logarithms ü§î",
    "section": "Assignment",
    "text": "Assignment\nBasic: Determine the derivative of \\(f(x) = e^x\\) using Python (see section on derivatives). Evaluate the derivative function \\(f'(x)\\) at \\(x=1, 2\\  and\\  3\\) and compare with the corresponding values of \\(f(x)\\). Explain in a short video what you‚Äôve noticed and elaborate.\nStretch: Expand your video with a presentation of the most beautiful formula in mathematics.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "numbertheory.html",
    "href": "numbertheory.html",
    "title": "Number Theory ü§î",
    "section": "",
    "text": "See book section\nNumber theory is a branch of mathematics that deals with the properties and relationships of numbers, especially integers. Python, like many programming languages, has several built-in types to handle numbers, each with its own capabilities. The three most common numerical types in Python are int for integers, float for floating-point numbers, and complex for complex numbers.\nLet‚Äôs start with a basic understanding of these number types:\nCode\na = 5\nb = -3\nc = 12345678901234567890  #Python 3 can handle very large integers.\nCode\na = 3.14159  # Pi to 5 decimal places.\nb = -0.01  # Negative float.\nc = 2.5e-4  # 2.5 times 10 to the power of -4.\nCode\na = complex(2, 3)  # 2 is the real part, 3 is the imaginary part.\nb = 3 + 4j  # Another way to create a complex number.\nNow, let‚Äôs illustrate some basic number theory concepts using these Python number types.\nCode\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\nprint(is_even(4))  # True\nprint(is_odd(7))  # True\n\n\nTrue\nTrue\nCode\nimport math\n\nprint(math.pi)  # 3.141592653589793\n\n\n3.141592653589793\nCode\ndef is_prime(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # True\nprint(is_prime(10))  # False\n\n\nTrue\nFalse\nNumber theory has many practical applications, particularly in cryptography, which is the study of encoding messages to keep them secure from unauthorized access. Many encryption algorithms rely on the difficulty of factoring large composite numbers into primes, which is a problem that is believed to be computationally infeasible for sufficiently large integers. As a result, number theory plays a crucial role in the security of modern communication systems.\nCode\nimport time\n\ntic = time.time()\n\ndef find_factors(num): \n  factors = []\n  for i in range(1, num+1):\n    if num % i == 0:\n      factors.append(i) \n  return factors\n\ntic = time.time()\nprint(find_factors(12)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997*999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\n\n[1, 2, 3, 4, 6, 12]\n0.0002880096435546875 secs\n[1, 997]\n0.00010514259338378906 secs\n[1, 999983]\n0.06030631065368652 secs\n[1, 997, 999983, 996983051]\n53.162992000579834 secs"
  },
  {
    "objectID": "numbertheory.html#assignment",
    "href": "numbertheory.html#assignment",
    "title": "Number Theory ü§î",
    "section": "Assignment",
    "text": "Assignment\nBasic: Make a short video explaining how factorization and prime numbers are used for encryption. Do proper research and use code demos.\nStretch: Expand your video with an exploration of the current state of quantum computing and it‚Äôs expected evolution. Discuss and illustrate the implications for current encryption methodologies. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "See book section\n\n\n\n\n\n\nRelationship Between Mathematical Functions and Functions in Python\nMathematical functions and functions in Python share some fundamental concepts, but they are implemented and used in different ways. Understanding their relationship can help us leverage the power of Python libraries like SymPy for symbolic mathematics and visualization libraries for plotting.\n1. Mathematical Functions:\nIn mathematics, functions are a fundamental concept that relates an input (or a set of inputs) to an output. A mathematical function typically takes one or more variables as inputs and produces a single output. Functions are often denoted by symbols like \\(f(x)\\) or \\(g(x, y)\\).\nExample: Mathematical Function\n\\[f(x) = x^2 + 6x + 9\\]\n2. Functions in Python:\nIn Python, functions are blocks of code that perform a specific task. They can take input arguments and return a result. Python functions can be defined using the def keyword and can be called multiple times within a program.\nExample: Python Function\n\n\nCode\ndef f(x):\n    return x**2 + 6*x + 9\n\n\n3. Using SymPy for Symbolic Mathematics:\nSymPy is a Python library for symbolic mathematics. It allows us to work with mathematical expressions in symbolic form, just like we do in mathematics. SymPy functions can be used to manipulate and simplify algebraic expressions.\nExample 1: Plotting a Mathematical Function\n\n\nCode\nfrom sympy import *\n\nx = symbols('x')\nf = x**2 + 6*x + 9\n\nplot(f, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x1051ed6d0&gt;\n\n\nExample 2: Plotting Multiple Mathematical Functions\n\n\nCode\nfd = 20*x - 40\n\nplot(f, fd, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x1051ed460&gt;\n\n\nExample 3: Plotting Multiple Mathematical Functions\n\n\nCode\ng = sin(x)\nh = sin(x - pi)\ngh = g+h\n\nplot(g, h, gh, (x, -2*pi, 2*pi), ylim=(-1, 1))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x127467400&gt;\n\n\nConclusion:\nThe relationship between mathematical functions and functions in Python revolves around the idea of relating inputs to outputs. Python provides a practical and versatile environment for working with functions, and libraries like SymPy and Matplotlib enhance the capabilities to handle symbolic mathematics and create visual representations of functions. By understanding this relationship, you can leverage Python‚Äôs functionality for mathematical computations and visualization, making it a powerful tool for various scientific and engineering tasks."
  },
  {
    "objectID": "orderofoperations.html",
    "href": "orderofoperations.html",
    "title": "Order of operations ü§î",
    "section": "",
    "text": "See book section\nMathematical Order of Operations\nMathematical order of operations refers to the rules that dictate the sequence in which mathematical operations should be performed in an expression. These rules ensure that every mathematical expression is evaluated in a consistent and unambiguous manner. The order of operations is also known as ‚ÄúPEMDAS‚Äù which is an acronym representing the sequence of operations: Parentheses, Exponents, Multiplication and Division (from left to right), and Addition and Subtraction (from left to right).\nPython, along with many other programming languages, follows the standard order of operations used in mathematics. The order of operations is essential to obtain accurate and meaningful results. Let‚Äôs break down each component of the order of operations and illustrate them with Python examples, including real-world scenarios.\n1. Parentheses\nParentheses are used to indicate which parts of an expression should be evaluated first. Expressions within parentheses are calculated before anything else.\nExample 1: Simple Parentheses\nCode\nresult = (4 + 3) * 2\nprint(result)  # Output: 14 (since 4 + 3 = 7, and 7 * 2 = 14)\n\n\n14\n2. Exponents\nExponents are mathematical operations that raise a base to a certain power.\nExample 2: Exponents\nCode\nresult = 2 ** 3 + 4\nprint(result)  # Output: 12 (since 2 ** 3 = 8, and 8 + 4 = 12)\n\n\n12\n3. Multiplication and Division\nThese operations are performed from left to right, whichever comes first in the expression.\nExample 3: Multiplication and Division\nCode\nresult = 10 / 2 * 3\nprint(result)  # Output: 15 (since 10 / 2 = 5, and 5 * 3 = 15)\n\n\n15.0\n4. Addition and Subtraction\nSimilarly, addition and subtraction are performed from left to right, whichever comes first in the expression.\nExample 4: Addition and Subtraction\nCode\nresult = 8 - 3 + 2\nprint(result)  # Output: 7 (since 8 - 3 = 5, and 5 + 2 = 7)\n\n\n7\nReal-World Examples\nLet‚Äôs consider some real-world examples where understanding the order of operations is crucial:\nExample 5: Shopping Calculations\nCode\nprice_per_item = 5\ntax_rate = 0.08\nquantity = 3\n\ntotal_cost = price_per_item * quantity + (price_per_item * quantity) * tax_rate\nprint(total_cost)  # Output: 16.2 (5 * 3 = 15, 15 + 15 * 0.08 = 16.2)\n\n\n16.2\nExample 6: Engineering Calculation\nCode\nimport math\n\nbase_length = 6.5 # a\nheight = 8.2 # b\n\nhypotenuse = math.sqrt(base_length ** 2 + height ** 2)\nprint(hypotenuse)  # Output: 10.463...\n\n\n10.463746938836012\nIn the second example, we use the Pythagorean theorem to find the length of the hypotenuse in a right-angled triangle. The order of operations ensures that the squares and addition are performed before the square root operation."
  },
  {
    "objectID": "orderofoperations.html#assignment",
    "href": "orderofoperations.html#assignment",
    "title": "Order of operations ü§î",
    "section": "Assignment",
    "text": "Assignment\nBasic: Make a short video explaining how to calculate distances between two coordinates. Do proper research and use code demos.\nStretch: Expand your video with an exploration of how to calculate the distance between geographical locations using their coordinates taking into account the curvature of the earth. Discuss and illustrate with code examples and maps. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g.¬†Linkedin or Medium), gather feedback and write a reflection on it."
  },
  {
    "objectID": "limits.html",
    "href": "limits.html",
    "title": "Limits",
    "section": "",
    "text": "See book section\n\n\n\nIntroduction\nIn calculus, the concept of a limit is fundamental. It forms the foundation for differentiation and integration, which are essential tools in fields ranging from engineering to economics. For business management and engineering students diving into data science, understanding limits can offer insights into how functions behave.\nWhat is a Limit?\nInformally, a limit describes the value a function approaches as its input (or variable) approaches a certain point. For instance, as \\(x\\) approaches the number \\(a\\), the limit of the function \\(f(x)\\) is the value \\(f(x)\\) gets close to.\nMathematically, we write this as:\n\\(\\mathop {\\lim }\\limits_{x \\to a} f(x) = L\\)\nWhere \\(L\\) is the value the function is approaching.\nWhy is it Important?\n\nPredicting Trends: In business, understanding where numbers are headed is crucial. By analyzing the limit of a function, you can predict future outcomes based on current data.\nRate of Change: For engineering projects, knowing how fast something is changing (like a temperature or a speed) can be essential. This rate of change is defined by derivatives, which are grounded in limits.\n\nCode Example in Python\nLet‚Äôs illustrate the concept of a limit using Python:\nConsider a company‚Äôs profit as it increases its price for a product. Due to demand elasticity, there‚Äôs an optimal price after which profit starts to decrease. This can be modeled by a function like: \\(f(p) = -p^2 + 20p\\) Where \\(p\\) is the price of the product.\n\n\nCode\nimport numpy as np\nimport matplotlib.pyplot as plt\n\ndef profit(p):\n    return -p**2 + 20*p\n\nprices = np.linspace(0, 20, 400)\nprofits = profit(prices)\n\nplt.plot(prices, profits)\nplt.title('Profit vs. Price')\nplt.xlabel('Price')\nplt.ylabel('Profit')\nplt.grid(True)\nplt.show()\n\n\n\n\n\nThe graph will show a peak profit. Using calculus and the concept of limits, we can determine the exact price that gives the maximum profit. This is futher discussed in the section on derivatives."
  }
]