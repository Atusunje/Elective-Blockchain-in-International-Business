[
  {
    "objectID": "orderofoperations.html",
    "href": "orderofoperations.html",
    "title": "Order of operations",
    "section": "",
    "text": "See book section\n\n\nMathematical Order of Operations\nMathematical order of operations refers to the rules that dictate the sequence in which mathematical operations should be performed in an expression. These rules ensure that every mathematical expression is evaluated in a consistent and unambiguous manner. The order of operations is also known as “PEMDAS” which is an acronym representing the sequence of operations: Parentheses, Exponents, Multiplication and Division (from left to right), and Addition and Subtraction (from left to right).\nIn Python, just like in mathematics, the order of operations is essential to obtain accurate and meaningful results. Let’s break down each component of the order of operations and illustrate them with Python examples, including real-world scenarios.\n1. Parentheses\nParentheses are used to indicate which parts of an expression should be evaluated first. Expressions within parentheses are calculated before anything else.\nExample 1: Simple Parentheses\n\n\nCode\nresult = (4 + 3) * 2\nprint(result)  # Output: 14 (since 4 + 3 = 7, and 7 * 2 = 14)\n\n\n14\n\n\n2. Exponents\nExponents are mathematical operations that raise a base to a certain power.\nExample 2: Exponents\n\n\nCode\nresult = 2 ** 3 + 4\nprint(result)  # Output: 12 (since 2 ** 3 = 8, and 8 + 4 = 12)\n\n\n12\n\n\n3. Multiplication and Division\nThese operations are performed from left to right, whichever comes first in the expression.\nExample 3: Multiplication and Division\n\n\nCode\nresult = 10 / 2 * 3\nprint(result)  # Output: 15 (since 10 / 2 = 5, and 5 * 3 = 15)\n\n\n15.0\n\n\n4. Addition and Subtraction\nSimilarly, addition and subtraction are performed from left to right, whichever comes first in the expression.\nExample 4: Addition and Subtraction\n\n\nCode\nresult = 8 - 3 + 2\nprint(result)  # Output: 7 (since 8 - 3 = 5, and 5 + 2 = 7)\n\n\n7\n\n\nReal-World Examples\nLet’s consider some real-world examples where understanding the order of operations is crucial:\nExample 5: Shopping Calculations\n\n\nCode\nprice_per_item = 5\ntax_rate = 0.08\nquantity = 3\n\ntotal_cost = price_per_item * quantity + (price_per_item * quantity) * tax_rate\nprint(total_cost)  # Output: 16.2 (5 * 3 = 15, 15 + 15 * 0.08 = 16.2)\n\n\n16.2\n\n\nExample 6: Engineering Calculation\n\n\nCode\nimport math\n\nbase_length = 6.5 # a\nheight = 8.2 # b\n\nhypotenuse = math.sqrt(base_length ** 2 + height ** 2)\nprint(hypotenuse)  # Output: 10.463...\n\n\n10.463746938836012\n\n\n\nIn the second example, we use the Pythagorean theorem to find the length of the hypotenuse in a right-angled triangle. The order of operations ensures that the squares and addition are performed before the square root operation.\nUnderstanding and following the order of operations is crucial in both mathematics and programming to avoid ambiguity and obtain accurate results. Python, along with many other programming languages, follows the standard order of operations used in mathematics."
  },
  {
    "objectID": "functions.html",
    "href": "functions.html",
    "title": "Functions",
    "section": "",
    "text": "See book section\n\n\nRelationship Between Mathematical Functions and Functions in Python\nMathematical functions and functions in Python share some fundamental concepts, but they are implemented and used in different ways. Understanding their relationship can help us leverage the power of Python libraries like SymPy for symbolic mathematics and visualization libraries for plotting.\n1. Mathematical Functions:\nIn mathematics, functions are a fundamental concept that relates an input (or a set of inputs) to an output. A mathematical function typically takes one or more variables as inputs and produces a single output. Functions are often denoted by symbols like \\(f(x)\\) or \\(g(x, y)\\).\nExample: Mathematical Function\n\\[f(x) = x^2 + 6x + 9\\]\n2. Functions in Python:\nIn Python, functions are blocks of code that perform a specific task. They can take input arguments and return a result. Python functions can be defined using the def keyword and can be called multiple times within a program.\nExample: Python Function\n\n\nCode\ndef f(x):\n    return x**2 + 6*x + 9\n\n\n3. Using SymPy for Symbolic Mathematics:\nSymPy is a Python library for symbolic mathematics. It allows us to work with mathematical expressions in symbolic form, just like we do in mathematics. SymPy functions can be used to manipulate and simplify algebraic expressions.\nExample 1: Plotting a Mathematical Function\n\n\nCode\nfrom sympy import *\n\nx = symbols('x')\nf = x**2 + 6*x + 9\n\nplot(f, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x1109f6760&gt;\n\n\nExample 2: Plotting Multiple Mathematical Functions\n\n\nCode\nfd = 20*x - 40\n\nplot(f, fd, ylim=(-50, 175))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x1109f6130&gt;\n\n\nExample 3: Plotting Multiple Mathematical Functions\n\n\nCode\ng = sin(x)\nh = sin(x - pi)\ngh = g+h\n\nplot(g, h, gh, (x, -2*pi, 2*pi), ylim=(-1, 1))\n\n\n\n\n\n&lt;sympy.plotting.plot.Plot at 0x132c68160&gt;\n\n\nConclusion:\nThe relationship between mathematical functions and functions in Python revolves around the idea of relating inputs to outputs. Python provides a practical and versatile environment for working with functions, and libraries like SymPy and Matplotlib enhance the capabilities to handle symbolic mathematics and create visual representations of functions. By understanding this relationship, you can leverage Python’s functionality for mathematical computations and visualization, making it a powerful tool for various scientific and engineering tasks."
  },
  {
    "objectID": "numbertheory.html",
    "href": "numbertheory.html",
    "title": "Number Theory",
    "section": "",
    "text": "See book section\n\n\nNumber theory is a branch of mathematics that deals with the properties and relationships of numbers, especially integers. Python, like many programming languages, has several built-in types to handle numbers, each with its own capabilities. The three most common numerical types in Python are int for integers, float for floating-point numbers, and complex for complex numbers.\nLet’s start with a basic understanding of these number types:\n\nIntegers (int): These are positive or negative whole numbers with no decimal point. Integers in Python can be of any size, limited only by the amount of memory your system has.\n\n\n\nCode\na = 5\nb = -3\nc = 12345678901234567890  #Python 3 can handle very large integers.\n\n\n\nFloating-Point (float): These are real numbers (i.e., numbers that can have a decimal point). The float type in Python designates a floating-point number. Float values are specified with a decimal point. Optionally, the character e or E followed by a positive or negative integer may be appended to specify scientific notation.\n\n\n\nCode\na = 3.14159  # Pi to 5 decimal places.\nb = -0.01  # Negative float.\nc = 2.5e-4  # 2.5 times 10 to the power of -4.\n\n\n\nComplex (complex): Complex numbers are numbers with a real and an imaginary component. In Python, complex numbers can be created using the complex(real, imag) function, or you can use the ‘j’ suffix in a literal to specify the imaginary part.\n\n\n\nCode\na = complex(2, 3)  # 2 is the real part, 3 is the imaginary part.\nb = 3 + 4j  # Another way to create a complex number.\n\n\nNow, let’s illustrate some basic number theory concepts using these Python number types.\n\nEven and Odd Numbers: An integer is even if it is divisible by 2, and odd if it’s not.\n\n\n\nCode\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\nprint(is_even(4))  # True\nprint(is_odd(7))  # True\n\n\nTrue\nTrue\n\n\n\nPrime Numbers: A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n\n\n\nCode\ndef is_prime(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # True\nprint(is_prime(10))  # False\n\n\nTrue\nFalse\n\n\n\nIrrational Numbers: An irrational number cannot be expressed as a ratio between two numbers and it does not repeat periodically. One example is the number π (pi), which Python can approximate with float. It’s important to remember that due to the limitations of representing real numbers in digital computers, certain mathematical properties might not hold exactly in computer arithmetic, especially with floating-point numbers.\n\n\n\nCode\nimport math\n\nprint(math.pi)  # 3.141592653589793\n\n\n3.141592653589793\n\n\nOne of the central themes in number theory is the study of prime numbers. A prime number is a positive integer greater than one that has no positive divisors other than one and itself. For example, 2, 3, 5, 7, 11, and 13 are all prime numbers. A positive integer that is not prime is called composite. The fundamental theorem of arithmetic states that every positive integer can be uniquely expressed as a product of primes. This means that there is only one way to write a positive integer as a product of primes, up to the order in which the factors are written.\nNumber theory has many practical applications, particularly in cryptography, which is the study of encoding messages to keep them secure from unauthorized access. Many encryption algorithms rely on the difficulty of factoring large composite numbers into primes, which is a problem that is believed to be computationally infeasible for sufficiently large integers. As a result, number theory plays a crucial role in the security of modern communication systems.\n\n\nCode\nimport time\n\ntic = time.time()\n\ndef find_factors(num): \n  factors = []\n  for i in range(1, num+1):\n    if num % i == 0:\n      factors.append(i) \n  return factors\n\ntic = time.time()\nprint(find_factors(12)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\n# print(find_factors(997*999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\n\n[1, 2, 3, 4, 6, 12]\n0.00026607513427734375 secs\n[1, 997]\n8.487701416015625e-05 secs\n[1, 999983]\n0.06220078468322754 secs\n2.002716064453125e-05 secs\n\n\n\nAssignment: Make a short video explaining how factorization and prime numbers are used for encryption. Do proper research and use code demos.\nStretch: Expand your video with an exploration of the current state of quantum computing and it’s expected evolution. Discuss and illustrate the implications for current encryption methodologies. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g. Linkedin), gather feedback and write a reflection on it."
  },
  {
    "objectID": "variables.html",
    "href": "variables.html",
    "title": "Variables",
    "section": "",
    "text": "See book section\n\n\nRelationship Between Mathematical Variables and Variables in Python\nIn mathematics, variables are symbols that represent unknown quantities or values. They allow us to write equations and express relationships between different elements. Similarly, in programming, variables play a crucial role in storing and manipulating data. Python, as a programming language, allows us to work with variables in ways that have similarities to mathematical variables but also exhibit some distinct characteristics.\n1. Assigning Values to Variables:\nIn both mathematics and Python, variables need to be assigned values before they can be used. In Python, the assignment is done using the “=” operator.\nExample: Python Variable\n\n\nCode\nx = 5\n\n\n2. Updating Values:\nIn mathematics, variables remain constant unless explicitly stated otherwise. In contrast, Python allows variables to be updated with new values during the course of a program.\nExample: Updating Python Variable\n\n\nCode\nx = 5\nx = x + 3  # The value of x is updated to 8\n\n\n3. Data Types:\nIn both mathematics and Python, variables can represent different types of data. In mathematics, variables are usually used to represent real or complex numbers. In Python, variables can hold a variety of data types, including integers, floating-point numbers, strings, lists, dictionaries, etc.\nExample: Different Data Types in Python\n\n\nCode\nx = 5  # Integer\ny = 3.14  # Floating-point number\nname = \"John\"  # String\ngrades = [90, 85, 95]  # List\nstudent_info = {\"name\": \"Alice\", \"age\": 25}  # Dictionary\n\n\n4. Mathematical Operations vs. Python Operations:\nBoth mathematical and Python variables can be used in mathematical operations, but there are some differences in notation. For instance, in mathematics, multiplication is often denoted with the “x” symbol, while in Python it is denoted by “*“. However, the operators for addition, subtraction, and division are the same in both contexts.\nExample: Python Operations\n\n\nCode\nx = 5\ny = 3\n\nresult = 2 * x + y  # The result will be 13\n\n\n5. Variable Names:\nIn both mathematics and Python, variable names are used to refer to specific values. However, there are some restrictions on variable names in Python. They cannot start with a number, and they cannot contain spaces or special characters except for underscores.\nExample: Valid and Invalid Variable Names in Python\n\n\nCode\n# Valid variable names\nage = 25\nfirst_name = \"John\"\ninterest_rate = 0.05\n\n# Invalid variable names (due to starting with a number)\n2nd_place = \"Silver\"\n\n\nIn conclusion, the relationship between mathematical variables and variables in Python revolves around the concept of representing and working with data. Python’s variables offer greater flexibility as they can hold different data types and be updated during program execution. Understanding these similarities and differences is essential for effective programming in Python and for translating mathematical concepts into code."
  },
  {
    "objectID": "summations.html",
    "href": "summations.html",
    "title": "Summations",
    "section": "",
    "text": "See book section\nMathematical Concept of Summations:\nIn mathematics, summation is a concept that represents the addition of a sequence of numbers or terms. It is denoted by the symbol “Σ” (sigma) and is used to express the total sum of a series of terms. The general form of a summation is:\n\\(\\sum_{n=1}^{k} f(n)\\)\nHere, \\(n\\) is the index variable that takes on values from 1 to \\(k\\) and \\(f(n)\\) is the function that defines the terms to be summed. The summation symbol indicates that we need to add up all the terms in the series for each value of \\(n\\).\nExample of Summation:\nLet’s consider the following example of a simple summation:\n\\(\\sum_{n=1}^{5} n\\)\nThis summation represents adding up all the integers from 1 to 5:\n1 + 2 + 3 + 4 + 5 = 15\nImplementing Summations in Python:\nIn Python, you can use loops to implement summations. The for loop is commonly used to iterate through a range of values and accumulate the sum.\nExample of Summation in Python:\n\n\nCode\n# Calculate the summation Σ (n = 1 to 5) n\ntotal_sum = 0\nfor n in range(1, 6):\n    total_sum += n\n\nprint(total_sum)  # Output: 15\n\n\n15\n\n\nRelation with Geometric Series:\nA geometric series is a specific type of summation in which each term is found by multiplying the previous term by a constant factor. The general form of a geometric series is:\n\\(\\sum_{n=0}^{k} ar^n\\)\nWhere \\(a\\) is the first term, \\(r\\) is the common ratio between consecutive terms, and \\(n\\) is the index variable. Geometric series are commonly used in various mathematical and financial applications.\n\n\nCode\nimport matplotlib.pyplot as plt\nimport numpy as np\n\ndef geom_series(a, k):\n  summation = sum(a**i for i in range(0, k+1))\n  return summation\n\nr1 = 0.9\nr2 = 0.75\nr3 = 0.5\nx = np.arange(2, 100)\ny1 = np.array([geom_series(r1, k) for k in x])\ny2 = np.array([geom_series(r2, k) for k in x])\ny3 = np.array([geom_series(r3, k) for k in x])\nplt.clf()\nplt.plot(x, y1)\nplt.plot(x, y2)\nplt.plot(x, y3)\nplt.show()\n\n\n\n\n\nApplication in Valuation of Investments - Discounting Cash Flows:\nThe concept of summations and geometric series is essential in finance for the valuation of investments using discounted cash flow (DCF) analysis. DCF is a widely used method to determine the present value of future cash flows.\nWhen a constant series of cash flows is expected to be received in the future (e.g., an investment that generates fixed returns over time), we can represent it as a geometric series. However, since money received in the future is not as valuable as money received today (due to the time value of money), we need to discount these future cash flows to their present value using an appropriate discount rate.\nThe present value (PV) of a series of future cash flows can be calculated using the geometric series formula:\n\\[\nPV = C * (\\frac{1}{(1 + r)^1} + \\frac{1}{(1 + r)^2} + ... + \\frac{1}{(1 + r)^k})\n\\] \\[\n= C * \\sum_{n=1}^{k} \\frac{1}{(1 + r)^n}\n\\] \\[\n= C*\\frac{1-1/(1+r)^k}{r}\n\\]\nWhere: - \\(PV\\) is the present value of the cash flows. - \\(C\\) is the constant cash flow received each period. - \\(r\\) is the discount rate (expressed as a decimal). - \\(n\\) is the number of periods (the investment horizon).\nBy discounting future cash flows back to their present value, we can compare investments with different time frames or cash flow patterns and make informed investment decisions.\n\n\nCode\nr = 0.1\na = 1/(1+r)\nk = 5\na = geom_series(a, k) - 1\nb = (1-(1/(1+r)**5))/r\n\nprint(a, b)\n\n\n3.7907867694084487 3.7907867694084505\n\n\nConclusion:\nSummations are a fundamental mathematical concept used to express the total sum of a sequence of terms. They find various applications in mathematics, computer science, and finance. In finance, summations and geometric series are utilized in discounted cash flow analysis to determine the present value of future cash flows, helping investors make informed decisions about their investments based on the time value of money. Python provides a convenient way to implement summations, making it a powerful tool for mathematical calculations and financial analysis."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Introduction",
    "section": "",
    "text": "Before starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O’Reilly Media, Inc.\na data science environment setup\n\nIn case you have not yet setup your environment you can use online notebook services like Google Colab or JupyterLab or Replit\n\n\nIn week 1 and 2 we’ll be covering chapter 1 with the following topics:\n\nNumber Theory\nOrder of Operations\nVariables\nFunctions\nSummations\nExponents\nLogarithms\nEuler’s Number and Natural Logarithms\n\nEuler’s Number\nNatural Logarithms\n\nLimits\nDerivatives\n\nPartial Derivatives\nThe Chain Rule\n\nIntegrals"
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction",
    "section": "",
    "text": "Before starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O’Reilly Media, Inc.\na data science environment setup\n\nIn case you have not yet setup your environment you can use online notebook services like Google Colab or JupyterLab or Replit\n\n\nIn week 1 and 2 we’ll be covering chapter 1 with the following topics:\n\nNumber Theory\nOrder of Operations\nVariables\nFunctions\nSummations\nExponents\nLogarithms\nEuler’s Number and Natural Logarithms\n\nEuler’s Number\nNatural Logarithms\n\nLimits\nDerivatives\n\nPartial Derivatives\nThe Chain Rule\n\nIntegrals"
  }
]