[
  {
    "objectID": "orderofoperations.html",
    "href": "orderofoperations.html",
    "title": "Order of operations",
    "section": "",
    "text": "See book section\nMathematical Order of Operations\nMathematical order of operations refers to the rules that dictate the sequence in which mathematical operations should be performed in an expression. These rules ensure that every mathematical expression is evaluated in a consistent and unambiguous manner. The order of operations is also known as “PEMDAS” which is an acronym representing the sequence of operations: Parentheses, Exponents, Multiplication and Division (from left to right), and Addition and Subtraction (from left to right).\nIn Python, just like in mathematics, the order of operations is essential to obtain accurate and meaningful results. Let’s break down each component of the order of operations and illustrate them with Python examples, including real-world scenarios.\n1. Parentheses\nParentheses are used to indicate which parts of an expression should be evaluated first. Expressions within parentheses are calculated before anything else.\nExample 1: Simple Parentheses\n\n\nCode\nresult = (4 + 3) * 2\nprint(result)  # Output: 14 (since 4 + 3 = 7, and 7 * 2 = 14)\n\n\n14\n\n\n2. Exponents\nExponents are mathematical operations that raise a base to a certain power.\nExample 2: Exponents\n\n\nCode\nresult = 2 ** 3 + 4\nprint(result)  # Output: 12 (since 2 ** 3 = 8, and 8 + 4 = 12)\n\n\n12\n\n\n3. Multiplication and Division\nThese operations are performed from left to right, whichever comes first in the expression.\nExample 3: Multiplication and Division\n\n\nCode\nresult = 10 / 2 * 3\nprint(result)  # Output: 15 (since 10 / 2 = 5, and 5 * 3 = 15)\n\n\n15.0\n\n\n4. Addition and Subtraction\nSimilarly, addition and subtraction are performed from left to right, whichever comes first in the expression.\nExample 4: Addition and Subtraction\n\n\nCode\nresult = 8 - 3 + 2\nprint(result)  # Output: 7 (since 8 - 3 = 5, and 5 + 2 = 7)\n\n\n7\n\n\nReal-World Examples\nLet’s consider some real-world examples where understanding the order of operations is crucial:\nExample 5: Shopping Calculations\n\n\nCode\nprice_per_item = 5\ntax_rate = 0.08\nquantity = 3\n\ntotal_cost = price_per_item * quantity + (price_per_item * quantity) * tax_rate\nprint(total_cost)  # Output: 16.2 (5 * 3 = 15, 15 + 15 * 0.08 = 16.2)\n\n\n16.2\n\n\nExample 6: Engineering Calculation\n\n\nCode\nimport math\n\nbase_length = 6.5 # a\nheight = 8.2 # b\n\nhypotenuse = math.sqrt(base_length ** 2 + height ** 2)\nprint(hypotenuse)  # Output: 10.463...\n\n\n10.463746938836012\n\n\n\nIn the second example, we use the Pythagorean theorem to find the length of the hypotenuse in a right-angled triangle. The order of operations ensures that the squares and addition are performed before the square root operation.\nUnderstanding and following the order of operations is crucial in both mathematics and programming to avoid ambiguity and obtain accurate results. Python, along with many other programming languages, follows the standard order of operations used in mathematics."
  },
  {
    "objectID": "numbertheory.html",
    "href": "numbertheory.html",
    "title": "Number Theory",
    "section": "",
    "text": "See book section\n\n\nNumber theory is a branch of mathematics that deals with the properties and relationships of numbers, especially integers. Python, like many programming languages, has several built-in types to handle numbers, each with its own capabilities. The three most common numerical types in Python are int for integers, float for floating-point numbers, and complex for complex numbers.\nLet’s start with a basic understanding of these number types:\n\nIntegers (int): These are positive or negative whole numbers with no decimal point. Integers in Python can be of any size, limited only by the amount of memory your system has.\n\n\n\nCode\na = 5\nb = -3\nc = 12345678901234567890  #Python 3 can handle very large integers.\n\n\n\nFloating-Point (float): These are real numbers (i.e., numbers that can have a decimal point). The float type in Python designates a floating-point number. Float values are specified with a decimal point. Optionally, the character e or E followed by a positive or negative integer may be appended to specify scientific notation.\n\n\n\nCode\na = 3.14159  # Pi to 5 decimal places.\nb = -0.01  # Negative float.\nc = 2.5e-4  # 2.5 times 10 to the power of -4.\n\n\n\nComplex (complex): Complex numbers are numbers with a real and an imaginary component. In Python, complex numbers can be created using the complex(real, imag) function, or you can use the ‘j’ suffix in a literal to specify the imaginary part.\n\n\n\nCode\na = complex(2, 3)  # 2 is the real part, 3 is the imaginary part.\nb = 3 + 4j  # Another way to create a complex number.\n\n\nNow, let’s illustrate some basic number theory concepts using these Python number types.\n\nEven and Odd Numbers: An integer is even if it is divisible by 2, and odd if it’s not.\n\n\n\nCode\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\nprint(is_even(4))  # True\nprint(is_odd(7))  # True\n\n\nTrue\nTrue\n\n\n\nPrime Numbers: A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n\n\n\nCode\ndef is_prime(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # True\nprint(is_prime(10))  # False\n\n\nTrue\nFalse\n\n\n\nIrrational Numbers: An irrational number cannot be expressed as a ratio between two numbers and it does not repeat periodically. One example is the number π (pi), which Python can approximate with float. It’s important to remember that due to the limitations of representing real numbers in digital computers, certain mathematical properties might not hold exactly in computer arithmetic, especially with floating-point numbers.\n\n\n\nCode\nimport math\n\nprint(math.pi)  # 3.141592653589793\n\n\n3.141592653589793\n\n\nOne of the central themes in number theory is the study of prime numbers. A prime number is a positive integer greater than one that has no positive divisors other than one and itself. For example, 2, 3, 5, 7, 11, and 13 are all prime numbers. A positive integer that is not prime is called composite. The fundamental theorem of arithmetic states that every positive integer can be uniquely expressed as a product of primes. This means that there is only one way to write a positive integer as a product of primes, up to the order in which the factors are written.\nNumber theory has many practical applications, particularly in cryptography, which is the study of encoding messages to keep them secure from unauthorized access. Many encryption algorithms rely on the difficulty of factoring large composite numbers into primes, which is a problem that is believed to be computationally infeasible for sufficiently large integers. As a result, number theory plays a crucial role in the security of modern communication systems.\n\n\nCode\nimport time\n\ntic = time.time()\n\ndef find_factors(num): \n  factors = []\n  for i in range(1, num+1):\n    if num % i == 0:\n      factors.append(i) \n  return factors\n\ntic = time.time()\nprint(find_factors(12)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\n# print(find_factors(997*999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\n\n[1, 2, 3, 4, 6, 12]\n0.0003409385681152344 secs\n[1, 997]\n0.00010919570922851562 secs\n[1, 999983]\n0.06199002265930176 secs\n2.4080276489257812e-05 secs\n\n\n\nAssignment: Make a short video explaining how factorization and prime numbers are used for encryption. Do proper research and use code demos.\nStretch: Expand your video with an exploration of the current state of quantum computing and it’s expected evolution. Discuss and illustrate the implications for current encryption methodologies. Provide a list of interesting resources on the matter.\nChallenge: Share your content online (e.g. Linkedin), gather feedback and write a reflection on it."
  },
  {
    "objectID": "index.html#prerequisites",
    "href": "index.html#prerequisites",
    "title": "Introduction",
    "section": "1 Prerequisites",
    "text": "1 Prerequisites\nBefore starting this module make sure you have:\n\naccess to the book Nield, T. (2022). Essential Math for Data Science. O’Reilly Media, Inc.\na data science environment setup\n\nIn week 1 and 2 we’ll be covering chapter 1 with the following topics:\n\nNumber Theory\nOrder of Operations\nVariables\nFunctions\nSummations\nExponents\nLogarithms\nEuler’s Number and Natural Logarithms\n\nEuler’s Number\nNatural Logarithms\n\nLimits\nDerivatives\n\nPartial Derivatives\nThe Chain Rule\n\nIntegrals"
  }
]