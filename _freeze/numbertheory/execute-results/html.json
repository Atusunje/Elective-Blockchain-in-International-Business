{
  "hash": "875032256c6a1f8071e3181fb856092c",
  "result": {
    "markdown": "---\ntitle: \"Number Theory \\U0001F914\"\n---\n\nSee book [section](https://learning.oreilly.com/library/view/essential-math-for/9781098102920/ch01.html#idm45252818933376){target=\"_blank\"}\n\n\n```{=html}\n<div class=\"ratio ratio-16x9 m-5 w-75\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/-QHff5pRdM8\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>\n\n</iframe>\n</div>\n```\n\nNumber theory is a branch of mathematics that deals with the properties and relationships of numbers, especially integers. Python, like many programming languages, has several built-in types to handle numbers, each with its own capabilities. The three most common numerical types in Python are `int` for integers, `float` for floating-point numbers, and `complex` for complex numbers.\n\nLet's start with a basic understanding of these number types:\n\n-   Integers (`int`): These are positive or negative whole numbers with no decimal point. Integers in Python can be of any size, limited only by the amount of memory your system has.\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\na = 5\nb = -3\nc = 12345678901234567890  #Python 3 can handle very large integers.\n```\n:::\n\n\n-   Floating-Point (`float`): These are real numbers (i.e., numbers that can have a decimal point). The float type in Python designates a floating-point number. Float values are specified with a decimal point. Optionally, the character e or E followed by a positive or negative integer may be appended to specify scientific notation.\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\na = 3.14159  # Pi to 5 decimal places.\nb = -0.01  # Negative float.\nc = 2.5e-4  # 2.5 times 10 to the power of -4.\n```\n:::\n\n\n-   Complex (`complex`): Complex numbers are numbers with a real and an imaginary component. In Python, complex numbers can be created using the `complex(real, imag)` function, or you can use the 'j' suffix in a literal to specify the imaginary part.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\na = complex(2, 3)  # 2 is the real part, 3 is the imaginary part.\nb = 3 + 4j  # Another way to create a complex number.\n```\n:::\n\n\n```{=html}\n<div class=\"ratio ratio-16x9 m-5 w-75\">\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/muBmJWOdoOA\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen>\n\n</iframe>\n</div>\n```\n\nNow, let's illustrate some basic number theory concepts using these Python number types.\n\n1.  **Even and Odd Numbers**: An integer is even if it is divisible by 2, and odd if it's not.\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\ndef is_even(n):\n    return n % 2 == 0\n\ndef is_odd(n):\n    return n % 2 != 0\n\nprint(is_even(4))  # True\nprint(is_odd(7))  # True\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nTrue\n```\n:::\n:::\n\n\n2.  **Irrational Numbers**: An irrational number cannot be expressed as a ratio between two numbers and it does not repeat periodically. One example is the number $\\pi$ (pi), which Python can approximate with float. It's important to remember that due to the limitations of representing real numbers in digital computers, certain mathematical properties might not hold exactly in computer arithmetic, especially with floating-point numbers.\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nimport math\n\nprint(math.pi)  # 3.141592653589793\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n3.141592653589793\n```\n:::\n:::\n\n\n3.  **Prime Numbers**: One of the central themes in number theory is the study of prime numbers. A prime number is a positive integer greater than one that has no positive divisors other than one and itself. For example, 2, 3, 5, 7, 11, and 13 are all prime numbers. A positive integer that is not prime is called composite. The fundamental theorem of arithmetic states that every positive integer can be uniquely expressed as a product of primes. This means that there is only one way to write a positive integer as a product of primes, up to the order in which the factors are written.\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\ndef is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))  # True\nprint(is_prime(10))  # False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nTrue\nFalse\n```\n:::\n:::\n\n\nNumber theory has many practical applications, particularly in cryptography, which is the study of encoding messages to keep them secure from unauthorized access. Many encryption algorithms rely on the difficulty of factoring large composite numbers into primes, which is a problem that is believed to be computationally infeasible for sufficiently large integers. As a result, number theory plays a crucial role in the security of modern communication systems.\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nimport time\n\ntic = time.time()\n\ndef find_factors(num): \n  factors = []\n  for i in range(1, num+1):\n    if num % i == 0:\n      factors.append(i) \n  return factors\n\ntic = time.time()\nprint(find_factors(12)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n\ntic = time.time()\nprint(find_factors(997*999983)) \ntoc = time.time()\nprint(f'{toc - tic} secs')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1, 2, 3, 4, 6, 12]\n0.0002880096435546875 secs\n[1, 997]\n0.00010514259338378906 secs\n[1, 999983]\n0.06030631065368652 secs\n[1, 997, 999983, 996983051]\n53.162992000579834 secs\n```\n:::\n:::\n\n\n------------------------------------------------------------------------\n\n## Assignment {.unnumbered}\n\n**Basic:** Make a short video explaining how factorization and prime numbers are used for encryption. Do proper research and use code demos.\n\n**Stretch:** Expand your video with an exploration of the current state of quantum computing and it's expected evolution. Discuss and illustrate the implications for current encryption methodologies. Provide a list of interesting resources on the matter.\n\n**Challenge:** Share your content online (e.g. Linkedin or Medium), gather feedback and write a reflection on it.\n\n",
    "supporting": [
      "numbertheory_files/figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}